第3章栈和队列

栈和队列是两种重要的线性结构。从数据结构角度看,栈和队列也是线性表,其特殊
性在于栈和队列的基本操作是线性表操作的子集,它们是操作受限的线性表,因此,可称
为限定性的数据结构。但从数据类型角度看,它们是和线性表大不相同的两类重要的抽
象数据类型。由于它们广泛应用在各种软件系统中,因此在面向对象的程序设计中,它们
是多型数据类型。本章除了讨论栈和队列的定义、表示方法和实现外,还将给出一些应用
的例子。

1 栈

3.
1.抽象数据类型栈的定义
3.1 

栈(stack) 是限定仅在表尾进行插入或删除操作的线性表。因此,对栈来说,表尾
tobo

端有其特殊含义,称为栈顶(p),相应地,表头端称为栈底(
tom )。不含元素的空表称

为空栈。
a), a为栈顶元素。栈中元素按a1,

假设栈S=(a1,a2,…,
n 
则称a1 为栈底元素,
n 
a2,…,的次序进栈,退栈的第一个元素应为栈顶元素。换句话说,栈的修改是按后进先出的原(a) 则进行的((n) 1(所示)。因此,栈又称为后进先出(t)

如图3.a) lastinfirstou的线性
表(简称LIFO 
结构), 1(所示的铁路调度站形象地表示。

它的这个特点可用图3.b) 


图3.

1 栈

(a)栈的示意图;(b)用铁路调度站表示栈
栈的基本操作除了在栈顶进行插入或删除外,还有栈的初始化、判空及取栈顶元素
等。下面给出栈的抽象数据类型的定义: 

・44・ 


ADTStack{
2,…
,


数据对象:D={ai|ai∈ElSet,i=1,n,n≥
0 }
数据关系:R1={<ai-1,ai>|a(m) (e) -1,ai∈D,i=2,…,n}
约定an端为栈顶,a1端为(i) 栈底
。


基本操作
: 

InitStck(&S)
操作结果:构造(a) 一个空栈S
。


DestyStk(&S)
初始条件:栈(r) S已(a) 存在。(c) (o) 操作结果:栈S被销毁
。


CleaStk(&S)
初始条件:栈(r) S(a) 已存在。(c) 操作结果:将S清为空栈
。


StackEmpty(S)
初始条件:栈S已存在
。
操作结果:若栈S为空栈,则返回TRUE,否则FALSE
。


StackLgth(S)
初始条件:栈S(e) 已存在。(n) 操作结果:返回S的元素个数,即栈的长度
。


GetTp(S,&e)
初始条件:栈(o) S已存在且非空
。
操作结果:用e返回S的栈顶元素
。


Push(&S,e)
初始条件:栈S已存在
。
操作结果:插入元素e为新的栈顶元素
。


Pop(&S,&e)
初始条件:栈S已存在且非空
。
操作结果:删除S的栈顶元素,并用e返回其值
。


StackTe(S,iit()) 
初始条件:栈S(r) 已(e) 存(s) 在且(v) 非(s) 空。(v) (a) 操作结果:从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦visit() 失败, 

则操作失效
。
}ADTStack


本书在以后各章中引用的栈大多为如上定义的数据类型,栈的数据元素类型在应用
程序内定义,并称插入元素的操作为入栈,删除栈顶元素的操作为出栈。

3.2 
栈的表示和实现
1.
和线性表类似,栈也有两种存储表示方法。

顺序栈,即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈
顶的数据元素,同时附设指针top指示栈顶元素在顺序栈中的位置。通常的习惯做法是
以top=0表示空栈,鉴于C语言中数组的下标约定从0开始,则当以C作描述语言时,如
此设定会带来很大不便;另一方面,由于栈在使用过程中所需最大空间的大小很难估计, 
因此,一般来说,在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是:先为
栈分配一个基本容量,然后在应用过程中,当栈的空间不够使用时再逐段扩大。为此,可

・45・ 


设定两个常量:STACK-INIT-SIZE(存储空间初始分配量)和STACKINCREMENT 
(存储空间分配增量), 并以下述类型说明作为顺序栈的定义。

typedefstruct{
SElemType 
*bse;
SElemType 
*top;(a) int 
stacksize;


}SqStack; 

其中,e指示栈的当前可使用的最大容量。栈的初始化操作为:按设定的初始分配

stacksiz
量进行第一次存储分配,base可称为栈底指针,在顺序栈中,它始终指向栈底的位置,若
base的值为NULL,则表明栈结构不存在。称top为栈顶指针,其初值指向栈底,即top= 
base可作为栈空的标记,每当插入新的栈顶元素时,指针top增1;删除栈顶元素时,指针
top减1,因此,2展示了顺

非空栈中的栈顶指针始终在栈顶元素的下一个位置上。图3.
序栈中数据元素和栈顶指针之间的对应关系。


图3.

2 栈顶指针和栈中元素之间的关系

以下是顺序栈的模块说明。

∥====
= 
ADTStack 
的表示与实现====
= 

∥-----栈的顺序存储表示----

#define 
STACK-INIT-SIZE 
100;∥ 存储空间初始分配
量
#define 
STACKINCREMENT 
10;∥ 存储空间分配增
量
typedefstruct{


SElemType 
*be;∥在栈构造之前和销毁之后,base的值为NULL 
SElemType 
*top(a) ;(s) ∥栈顶指针
istacksize;∥当前已分配的存储空间,以元素为单位

}SqStack;(t) (n) ∥-----基本操作的函数原型说明----
-
StatusInitStack(SqStack 
&S)
;
∥ 构造一个空栈
S
StatusDySack(SqStack 
&S)
;
∥ 销(e) 毁(s) 栈(r) S,S(t) (o) (t) 不再存
在
StatusClearStack(SqStack 
&S)
;
∥ 把S置为空
栈
StatusSkEpy(SqStackS)
;
∥ 若(t) 栈(a) S为(m) 空(t) 栈,(c) 则返回TRUE,否则返回FALSE


・46・ 


intStkLgh(SqSkS); 
∥ 返(a) 回(e) S(n) 的(t) 元素个(t) 数,(c) (a) (c) 即栈的长度
StatusGetTop(SqSkS,SElType 
&e); 
∥ 若栈不空,则用(t) e(c) 返回S的(e) 栈顶元素,(m) (a) 并返回OK;否则返回ERROR 
StatusPush(SqStack 
&S,SElemTypee); 
∥ 插入元素e为新的栈顶元素
StatusPop(SqStk 
&S,SElType 
&e); 
∥ 若栈不空,则(a) 删除S的栈(e) 顶(m) 元素,(c) 用e返回其值,并返回OK;否则返回ERROR 
StatusStackTraverse(SqStackS,Status(*visit)()); 
∥ 从栈底到栈顶依次对栈中每个元素调用函数visit()。一旦visit() 失败,则操作失败

∥-----基本操作的算法描述(部分)-----

StatusInitStack(SqStack 
&S){
∥ 构造一个空栈
S 
Sbe= 
(SElemType 
*)mlloc(STACK-INIT-SIZE 
*sizeof(SElemType)); 
if(!S(s) (a) (.) .se)it(VRLW);(a) ∥存储分配失败

bxOEFO
S.o.ae;(e) 

tp=S(a) bs
S.tcie=SAKNTIE;


sakzTC-II-SZreturnOK;(s) }∥InitStack 

StatsGetTop(SqSkS,SElType&e){
∥ 若(u) 栈不空,则用(t) e(a) 返回S的(e) 栈(m) 顶元素,(c) 并返回OK;否则返回ERROR 

if(Sp==Sbse)returnERROR;
e= *(S(o) (t) (.) top-1);(a) (.) returnOK;(.) 

}∥GetTop 

StatusPush(SqStack 
&S,SElemTypee){
∥ 插入元素e为新的栈顶元素
if(Stp-S.bsakie){∥栈满,追加存储空间

.oae 
>
= 
Scsz
S.ae= 
(SlTp)(t) ralc(Sbs


bsEmye*(s) (.) elo.ae,(S(e) .tcszTCICEET)*szoSlmye)); 

sakie+ 
SAKNRMNief(EeTp
if(!SbseiOEFO


.ae)xt(VRLW);∥存储分配失败

S.o= 
Sbs.tcsz

tp.ae+ 
Ssakie;
S.tcsz= 
SAKNRMN


sakie+TCICEET;
}
*S.o= 
e;


tp+
+ 
returnOK;
}∥Push 

StatusPop(SqStk 
&S,SElType 
&e){
∥ 若栈不空,则(a) 删除S的栈(e) 顶元素,(m) (c) 用e返回其值,并返回
OK;否则返回ERROR 
if(.o=bsrtrRO

Stp 
=Sae)eunERR;
e= 
-.
o


*-Stp;(.) returnOK;
}∥Pop 

图3.3链栈示意图
・47・ 


栈的链式表示――3所示。由于栈的操作是线性表操作的特例,

―链栈如图3.则链栈
的操作易于实现,在此不作详细讨论。
2 栈的应用举例

3.
由于栈结构具有后进先出的固有特性,致使栈成为程序设计中的有用工具。本节将
讨论几个栈应用的典型例子。

3.1 
数制转换
2.
十进制数
N 
和其他
d 
进制数的转换是计算机实现计算的基本问题,其解决方法很

多,其中一个简单算法基于下列原理: 
N 
=(
N 
divd)×d+
N 
modd 
(其中:div为整除运算,mod为求余运算) 
例如:(10=(8,其运算过程如下:

1348)2504)

N Ndiv8 Nmod8 
1348 168 4 
168 21 0 
21 2 5 
2 0 2 

假设现要编制一个满足下列要求的程序:对于输入的任意一个非负十进制整数,打印
输出与其等值的八进制数。由于上述计算过程是从低位到高位顺序产生八进制数的各个
数位,而打印输出,一般来说应从高位到低位进行,恰好和计算过程相反。因此,若将计算
过程中得到的八进制数的各位顺序进栈,则按出栈序列打印输出的即为与输入对应的八
进制数。

voidconversion(){
∥ 对于输入的任意一个非负十进制整数,打印输出与其等值的八进制数
IniSck(S); ∥ 构造空栈

scanf("(a) (t) (t) %d",N); 

while(N){
Push(S,N%8); 
N=N/8;

} 

while(!SckEmpty(s)){
Pop(S,e);(a) (t) printf("%d",e); 

}
}∥conversion 

算法3.

1 

这是利用栈的后进先出特性的最简单的例子。在这个例子中,栈操作的序列是直线
・48・ 


式的,即先一味地入栈,然后一味地出栈。也许,有的读者会提出疑问:用数组直接实现不
也很简单吗? 仔细分析上述算法不难看出,栈的引入简化了程序设计的问题,划分了不同
的关注层次,使思考范围缩小了。而用数组不仅掩盖了问题的本质,还要分散精力去考虑
数组下标增减等细节问题。

2.括号匹配的检验
3.2 

假设表达式中允许包含两种括号:圆括号和方括号,其嵌套的顺序随意,即([]()) 或
[([][])] 等为正确的格式,[(]) 或([()) 或(()]) 均为不正确的格式。检验括号是否
匹配的方法可用“期待的急迫程度”这个概念来描述。例如考虑下列括号序列: 

[([][])]

12345678 
当计算机接受了第一个括号后,它期待着与其匹配的第八个括号的出现,然而等来的却是
第二个括号,此时第一个括号“[只(”) 能暂时靠边,而迫切等待与第二个括号相匹配的、第七
个括号“)的(”) 出现,类似地,因等来的是第三个括号“[,(”) 其期待匹配的程度较第二个括
号更急迫,则第二个括号也只能靠边,让位于第三个括号,显然第二个括号的期待急迫性
高于第一个括号;在接受了第四个括号之后,第三个括号的期待得到满足,消解之后,第二
个括号的期待匹配就成为当前最急迫的任务了,……, 依次类推。可见,这个处理过程恰
与栈的特点相吻合。由此,在算法中设置一个栈,每读入一个括号,若是右括号,则或者使
置于栈顶的最急迫的期待得以消解,或者是不合法的情况;若是左括号,则作为一个新的
更急迫的期待压入栈中,自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。
另外,在算法的开始和结束时,栈都应该是空的。此算法将留给读者作为习题完成。

3.3 
行编辑程序
2.
一个简单的行编辑程序的功能是:接受用户从终端输入的程序或数据,并存入用户的
数据区。由于用户在终端上进行输入时,不能保证不出差错,因此,若在编辑程序中,“每
接受一个字符即存入用户数据区”的做法显然不是最恰当的。较好的做法是,设立一个输
入缓冲区,用以接受用户输入的一行字符,然后逐行存入用户数据区。允许用户输入出差
错,并在发现有误时可以及时更正。例如,当用户发现刚刚键入的一个字符是错的时,可
补进一个退格符“#”,以表示前一个字符无效;如果发现当前键入的行内差错较多或难以
补救,则可以键入一个退行符“@”,以表示当前行中的字符均无效。例如,假设从终端接
受了这样两行字符: 

whli##ilr#e(s#*s)
outcha@putchar(*s=#++)
;


则实际有效的是下列两行: 

while(*s)
putchar(*s++)
;


为此,可设这个输入缓冲区为一个栈结构,每当从终端接受了一个字符之后先作如下
・49・ 


判别:如果它既不是退格符也不是退行符,则将该字符压入栈顶;如果是一个退格符,则从
栈顶删去一个字符;如果它是一个退行符,则将字符栈清为空栈。上述处理过程可用算法

2描述。

3.
voidLiEdit()
{∥利用(n) 字(e) 符栈S,从终端接收一行并传送至调用过程的数据区
。
InitStack(S); ∥构造空栈
S
ch=gethar(); ∥从终端接收第一个字
符
while(ch!=(c) EOF){∥EOF为全文结束
符


while(ch 
!
= 
EOF&&ch 
!='\n(') ){

switch(ch){
case'#':Pop(S,c); break;∥仅当栈非空时退栈
case'@':ClrStck(S);brek;∥重置S为空栈
}
default∶Push(S(a) (e) ,ch);(a) break(a) ;∥有效字符进栈,未考虑栈满情形

} 
ch=getchar(); ∥从终端接收下一个字符

将从栈底到栈顶的栈内字符传送至调用过程的数据区
;
ClrStck(S); ∥重置S为空栈if(c(a) (e) h!=E(a) OF)ch=getchar()
;


}
DstroyStack(S);}∥L(e) ineEdit


算法3.

2 

2.迷宫求解
3.4 
求迷宫中从入口到出口的所有路径是一个经典的程序设计问题。由于计算机解迷宫
时,通常用的是“穷举求解”的方法,即从入口出发,顺某
一方向向前探索,若能走通,则继续往前走;否则沿原
路退回,换一个方向再继续探索,直至所有可能的通路
都探索到为止。为了保证在任何位置上都能沿原路退
回,显然需要用一个后进先出的结构来保存从入口到当
前位置的路径。因此,在求迷宫通路的算法中应用“栈” 
也就是自然而然的事了。

首先,在计算机中可以用如图3.

4所示的方块图表
示迷宫。图中的每个方块或为通道(以空白方块表示), 
或为墙(以带阴影线的方块表示)。所求路径必须是简图3.4 迷宫
单路径,即在求得的路径上不能重复出现同一通道块。

假设“当前位置”指的是“在搜索过程中某一时刻所在图中某个方块位置”,则求迷宫
中一条路径的算法的基本思想是:若当前位置“可通”,则纳入“当前路径”,并继续朝“下一

・50・ 



位置”探索,即切换“下一位置”为“当前位置”,如此重复直至到达出口;若当前位置“不可
通”,则应顺着“来向”退回到“前一通道块”,然后朝着除“来向”之外的其他方向继续探索; 
若该通道块的四周4个方块均“不可通”,则应从“当前路径”上删除该通道块。所谓“下一
位置”指的是“当前位置”四周4个方向(东、南、西、北)上相邻的方块。假设以栈S记录
“当前路径”,则栈顶中存放的是“当前路径上最后一个通道块”。由此,“纳入路径”的操作
即为“当前位置入栈”;“从当前路径上删除前一通道块”的操作即为“出栈”。

求迷宫中一条从入口到出口的路径的算法可简单描述如下: 

设定当前位置的初值为入口位置; 

do
若
{
当前位置可通
,
则{ 将当前位置插入栈顶;∥ 纳入路
径
若该位置是出口位置,则结束; 求得路径存放在栈
中
} 
否则切换当前位置的东邻方块为新的当前位置;
∥


否则
, 
若栈不空且栈顶位置尚有其他方向未经探索, 
则设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻块; 
若栈不空但栈顶位置的四周均不可通, 
则{ 删去栈顶位置;∥ 从路径中删去该通道块
若栈不空,则重新测试新的栈顶位置, 
} 
直至找到一个可通的相邻块或出栈至栈空; 

}while(栈不空); 

在此,尚需说明一点的是,所谓当前位置可通,指的是未曾走到过的通道块,即要求该
方块位置不仅是通道块,而且既不在当前路径上(否则所求路径就不是简单路径), 也不是
曾经纳入过路径的通道块(否则只能在死胡同内转圈)。

typedefstruct{
int 
ord;∥ 通道块在路径上的"序号
"
PosType 
at;∥ 通道块在迷宫中的"坐标位置
"
int 
di;(e) (s) ∥ 从此通道块走向下一通道块的"方向
"


}SElemType;∥ 栈的元素类型

StatusMazePath(MazeTypemaze,PosTypestart,PosTypd){
∥ 若迷宫maze中存在从入口start到出口end的通道,则求(ee) 得一条存放在栈中((n) 从栈底到栈
∥ 顶), 并返回TRUE;否则返回FALSE 

InitSk(S);curpos= 
start;∥ 设定"当前位置"为"入口位置
" 
do{t(s) (r) (u) (c) ep(t) =(c) 1;∥ 探索第一步

if(Pass(cpos)){∥ 当前位置可以通过,即是未曾走到过的通道块
FootPint(c(r) (u) urpos); ∥ 留下足迹
e= ((r) ep,curpos,
1 
); 
Psh(S,e);(t) (s) (r) (u) (c) ∥ 加入路径
if(c(u) urpos==end)retrn(TRUE); ∥ 到达终点(出口) 
curpos= 
NxtPos(curpos(u) ,1 
); ∥ 下一位置是当前位置的东邻
curstep++;(e) ∥ 探索下一步

・51・ 


}∥if
lse{∥ 当前位置不能通过if(e) (!SakEmpty(S))
{Pop(S(t) ,e);(c) whled=
4 
&&!ScEtS))
{


ie(.i=tkpy(

MrPit(.et);Pp((a) e);(m) 留下不能通过的标记,

krnesaoS,∥ 并退回一步}∥w(a) hile 
if(.i<4){

de.i(e) uh(S,e); 换下一个方向探索

d++; Ps∥
poetoesa.i); 
∥

}∥i(r) (u) (c) fs= 
NxPs(.eted设定当前位置是该新方向上的相邻块

}∥if 

}∥else 

}while(!StckEmpty(S)); 

turn(FALSE);(a) 

}∥M(e) (r) azePath 

算法3.

3 

2.表达式求值
3.5 
表达式求值是程序设计语言编译中的一个最基本问题。它的实现是栈应用的又一个
典型例子。这里介绍一种简单直观、广为使用的算法,通常称为“算符优先法”。
要把一个表达式翻译成正确求值的一个机器指令序列,或者直接对表达式求值,首先
要能够正确解释表达式。例如,要对下面的算术表达式求值: 
4+2×3-10/5 
首先要了解算术四则运算的规则。即: 

(1)先乘除,后加减;
(2)从左算到右;
(3)先括号内,后括号外。
由此,这个算术表达式的计算顺序应为
4+2×3-10/5=4+6-10/5=10-10/5=10-2=8 
算符优先法就是根据这个运算优先关系的规定来实现对表达式的编译或解释执行的。
任何一个表达式都是由操作数(operand)、运算符(operator)和界限符(delimiter)组
成的,我们称它们为单词。一般地,操作数既可以是常数也可以是被说明为变量或常量的
标识符;运算符可以分为算术运算符、关系运算符和逻辑运算符3类;基本界限符有左右
括号和表达式结束符等。为了叙述的简洁,我们仅讨论简单算术表达式的求值问题。这
种表达式只含加、减、乘、除4种运算符。读者不难将它推广到更一般的表达式上。

我们把运算符和界限符统称为算符,它们构成的集合命名为OP 
。根据上述3条运
算规则,在运算的每一步中,任意两个相继出现的算符θ1 和θ2 之间的优先关系至多是下
面3种关系之一; 

θ1<θ2 θ1 的优先权低于θ2
・52
・



θ1=θ2 θ1 的优先权等于θ2
θ1>θθ1 的优先权高于
θ
表3.算符之间的这种优关系。

1定义了(2) 先(2) 

表3.算符间的优先关系

1 

θ1 
θ2 
+ 

-
* 
/
()
# 

+ -* / ( ) # 
> > < < < > > 
> > < < < > > 
> > > > < > > 
> > > > < > > 
< < < < < . 
> > > > > > 
< < < < < = 

由规则(3),+、-、*和/为θ1 时的优先性均低于“(”但高于“)”,由规则(2), 当θ1= 
θ2 时,令θ1>θ2,“#”是表达式的结束符。为了算法简洁,在表达式的最左边也虚设一个
“#”构成整个表达式的一对括号。表中的“(”=“)表(”) 示当左右括号相遇时,括号内的运
算已经完成。同理,“#”=“#”表示整个表达式求值完毕。“)”与“(”、“#”与“)”以及“(” 
与“#”之间无优先关系,这是因为表达式中不允许它们相继出现,一旦遇到这种情况,则
可以认为出现了语法错误。在下面的讨论中,我们暂假定所输入的表达式不会出现语法
错误。

为实现算符优先算法,可以使用两个工作栈。一个称做OPTR,用以寄存运算符;另
一个称做OPND,用以寄存操作数或运算结果。算法的基本思想是: 

(1)首先置操作数栈为空栈,表达式起始符“#”为运算符栈的栈底元素;
(2)依次读入表达式中每个字符,若是操作数则进OPND 栈,若是运算符则和
OPTR 栈的栈顶运算符比较优先权后作相应操作,直至整个表达式求值完毕(即OPTR 
栈的栈顶元素和当前读入的字符均为“#”)。
算法3.

4描述了这个求值过程。

OperdTypEltEpin()
法
{
。设O

∥ 算(a) 术表达(e) 式求(v) 值(u) 的(e) 算(x) 符(r) 优(e) 先(s) 算(o) (n) PTR和OPND分别为运算符栈和运算数栈
,
∥OP为运算符集合
。
InttcOTuh(PR,#)
;


iSak(PR); PsOT'
'
initStack(OPND); c= 
getchar()
;
while(c!='#'‖GeTop(OPTR)!='#')
{


if(!In(c,OP)){Push((O(t) PND,c);c=getchar();} ∥ 不是运算符则进栈

else
switch(Precede(GetTop(OPTR),c))
{


case'<': ∥ 栈顶元素优先权
低
Push(OPTR,c);c= 
getchar()
;
break;


case'=': ∥ 脱括号并接收下一字
符
Pop(OPTR,x); c=getchar()
;
break;


・53・ 


case'>': ∥ 退栈并将运算结果入栈 
Pop(OPTR,theta); 
Pop(OPND,b); Pop(OPND,a); 
Push(OPND,Operate(a,theta,b)); 
break; 
}∥ switch 
}∥ while 
returnGetTop(OPND); 
}∥ EvaluateExpression 
算法 3.4 
算法中还调用了两个函数。其中Precede是判定运算符栈的栈顶运算符θ1 与读入
的运算符θ2 之间优先关系的函数;Operate为进行二元运算a θb 的函数,如果是编译表
达式,则产生这个运算的一组相应指令并返回存放结果的中间变量名;如果是解释执行表
达式,则直接进行该运算,并返回运算的结果。
例3-1 利用算法EvaluateExpression-reduced对算术表达式3*(7-2)求值,操作
过程如下所示。
步骤OPTR栈OPND栈输入字符 主要操作
1 # 3*(7-2)# PUSH(OPND,‘3’) 
2 # 3 *(7-2)# PUSH(OPTR,‘*’) 
3 #* 3 (7-2)# PUSH(OPTR,‘(’) 
4 #*( 3 7-2)# PUSH(OPND,‘7’) 
5 #*( 37 -2)# PUSH(OPTR,‘-’) 
6 #*(- 37 2)# PUSH(OPND,‘2’) 
7 #*(- 372 )# operate(‘7’,‘-’,‘2’) 
8 #*( 35 )# POP(OPTR){消去一对括号} 
9 #* 35 # operate(‘3’,‘*’,‘5’) 
10 # 15 # RETURN(GETTOP(OPND)) 
3.3 栈与递归的实现
栈还有一个重要应用是在程序设计语言中实现递归。一个直接调用自己或通过一系
列的调用语句间接地调用自己的函数,称做递归函数。
递归是程序设计中一个强有力的工具。其一,有很多数学函数是递归定义的,如大家
熟悉的阶乘函数
Fact(n)= 1 n・Fact(n { -1) 若n =0 
若n >0 (3-1) 
2阶Fibonacci数列
Fib(n)= 
01 
Fib(n -1)+Fib(n -2) 
ì
.
í
.. 
.. 
若n =0 
若n =1 
其他情形
(3-2) 
・54・

和Ackerman函数
Ack(m ,n)= 
n +1 
Ack(m -1,1) 
Ack(m -1,Ack(m ,n -1)) 
ì
.
í
.. 
.. 
若m =0 
若n =0 
其他情形
(3-3) 
等;其二,有的数据结构,如二叉树、广义表等,由于结构本身固有的递归特性,则它们的操
作可递归地描述;其三,还有一类问题,虽然问题本身没有明显的递归结构,但用递归求解
比迭代求解更简单,如八皇后问题、Hanoi塔问题等。
例3-2 (n 阶Hanoi塔问题)假设有3个分别命名为X、Y 和Z的塔座,在塔座X上
图3.5 3阶Hanoi塔问题
的初始状态
插有n 个直径大小各不相同、依小到大编号为1,2,…, 
n 的圆盘(如图3.5所示)。现要求将X轴上的n 个圆
盘移至塔座Z上并仍按同样顺序叠排,圆盘移动时必
须遵循下列规则: 
(1)每次只能移动一个圆盘; 
(2)圆盘可以插在X、Y和Z中的任一塔座上; 
(3)任何时刻都不能将一个较大的圆盘压在较小
的圆盘之上。
如何实现移动圆盘的操作呢? 当n=1时,问题比较简单,只要将编号为1的圆盘从
塔座X直接移至塔座Z上即可;当n>1时,需利用塔座Y 作辅助塔座,若能设法将压在
编号为n 的圆盘之上的n-1个圆盘从塔座X(依照上述法则)移至塔座Y 上,则可先将
编号为n 的圆盘从塔座X移至塔座Z上,然后再将塔座Y上的n-1个圆盘(依照上述法
则)移至塔座Z上。而如何将n-1个圆盘从一个塔座移至另一个塔座的问题是一个和
原问题具有相同特征属性的问题,只是问题的规模小1,因此可以用同样的方法求解。由
此可得如算法3.5所示的求解n 阶Hanoi塔问题的C函数。
voidhanoi(intn,charx,chary,charz) 
∥ 将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬到 
∥ 塔座z上,y可用作辅助塔座。 
∥ 搬动操作move(x,n,z)可定义为(c是初值为0的全局变量,对搬动计数): 
∥ printf("%i.Movedisk %ifrom %c to %c\n",++c,n,x,z); 
1 { 
2 if(n==1) 
3 move(x,1,z); ∥将编号为1的圆盘从x移到z 
4 else{ 
5 hanoi(n-1,x,z,y); ∥将x上编号为1至n-1的圆盘移到y,z作辅助塔
6 move(x,n,z); ∥将编号为n的圆盘从x移到z 
7 hanoi(n-1,y,x,z); ∥将y上编号为1至n-1的圆盘移到z,x作辅助塔
8 } 
9 } 
算法 3.5 
显然,这是一个递归函数,在函数的执行函数中,需多次进行自我调用。那末,这个递
归函数是如何执行的? 先看任意两个函数之间进行调用的情形。
・55・

与汇编程序设计中主程序和子程序之间的链接及信息交换相类似,在高级语言编制
的程序中,调用函数和被调用函数①之间的链接及信息交换需通过栈来进行。

通常,当在一个函数的运行期间调用另一个函数时,在运行被调用函数之前,系统需
先完成3件事:(1)将所有的实在参数、返回地址等信息传递给被调用函数保存;(2)为被
调用函数的局部变量分配存储区;(3)将控制转移到被调函数的入口。而从被调用函数返
回调用函数之前,系统也应完成3件工作:(1)保存被调函数的计算结果;(2)释放被调函
数的数据区;(3)依照被调函数保存的返回地址将控制转移到调用函数。当有多个函数构
成嵌套调用时,按照“后调用先返回”的原则,上述函数之间的信息传递和控制转移必须通
过“栈”来实现,即系统将整个程序运行时所需的数据空间安排在一个栈中,每当调用一个
函数时,就为它在栈顶分配一个存储区,每当从一个函数退出时,就释放它的存储区,则当
前正运行的函数的数据区必在栈顶。例如,在图3.c) i

6(所示主函数man中调用了函数
first,而在函数first中又调用了函数second, 6(展示了当前正在执行函数sec

则图3.a) 
ond中某个语句时栈的状态,而图3.b) econd退出之后正执行函数first中

6(展示从函数s
某个语句时栈的状态(图中以语句标号表示返回地址)。

2 1 ・ 
i m ・ 
n ・ 
x i m 
y n 
▲ 栈顶

void 
first(ints,intt); 
void 
second(intd); 
void 
main(){

int 
m,n;
. 
first(m,n)
;
1:
. 

} 

int 
first(ints,intt){

int 
i;
. 
second(i)
;
2:
. 

} 

int 
second(intd){
int 
x,y; 
. 

} 

(c) 
・・・ 

1 ・ 
m ・ 
n ・ ・・・ 
i m 
n 

(a) 
▲ 

栈顶

(b) 
图3.6 主函数main执行期间运行栈的状态

一个递归函数的运行过程类似于多个函数的嵌套调用,只是调用函数和被调用函数
是同一个函数,因此,和每次调用相关的一个重要的概念是递归函数运行的“层次”。假设
调用该递归函数的主函数为第0层,则从主函数调用递归函数为进入第1层;从第
i 
层递
归调用本函数为进入“下一层”,即第i+1层。反之,退出第
i 
层递归应返回至“上一层”, 

① 若在函数A中调用了函数B,则称函数A为调用函数,称函数B为被调用函数。
・56・ 


即第i-1层。为了保证递归函数正确执行,系统需设立一个“递归工作栈”①作为整个递
归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”,其中包
括所有的实在参数、所有的局部变量以及上一层的返回地址。每进入一层递归,就产生一
个新的工作记录压入栈顶。每退出一层递归,就从栈顶弹出一个工作记录,则当前执行层
的工作记录必是递归工作栈栈顶的工作记录,称这个记录为“活动记录”,并称指示活动记
录的栈顶指针为“当前环境指针”。

例如,图3.
hanoi(3,a,b,c) (3-4) 

7展示了语句

执行过程(从主函数进入递归函数到退出递归函数而返回至主函数)中递归工作栈状态的
变化情况。由于算法3.则每个工作记录包含5个

5所示的递归函数中只含4个值参数, 
数据项:返回地址和4个实在参数,并以递归函数中的语句行号表示返回地址,同时假设
主函数的返回地址为0。图3.

7中.表示栈顶指针。

实际上,在调用函数和被调用函数之间不一定传递参数的值,也可以传递参数的地
址。通常,每个程序设计语言都有它自己约定的传递方法(包括被调用函数的执行结果如
何返回调用函数等), 读者将会在后续课程中学到其细节。

由于递归函数结构清晰,程序易读,而且它的正确性容易得到证明,因此,利用允许递
归调用的语言(例如C语言)进行程序设计时,给用户编制程序和调试程序带来很大方
便。因为对这样一类递归问题编程时,不需用户自己而由系统来管理递归工作栈。

递归运行
的层次
运行语句
行号
递归工作栈状态
(返址,n值,x值,y值,z值) 塔与圆盘的状态说明
1 1,2,4, 
5 . 0,3,a,b,
c 
由主函数进入第一层递归
后,运行至语句(行)5,因递
归调用而进入下一层。
2 1,2,4, 
5 . 6,2,a,c,
b 
0,3,a,b,c 
由第一层的语句(行)5进
入第二层递归,执行至语句
(行)5。
3 1,2,3, 
9 
. 6,1,a,b,
c 
6,2,a,c,b 
0,3,a,b,c 
由第二层的语句(行)5进
入第三层递归,执行语句
(行)3,将1号圆盘由a移
至c后从语句(行)9退出第
三层递归,返回至第二层的
语句(行)6。
2 6,7 . 6,2,a,c,b 
0,3,a,b,c 
将2号圆盘由a移至b后, 
从语句(行)7进入下一层
递归。

图3.i塔的递归函数运行示意图

7 Hano

机制
①
。
在实际的系统中,一般都综合考虑递归调用和非递归调用统一处理,在此,我们只讨论直接递归调用的处理

・57・ 


递归运行
的层次
运行语句
行号
递归工作栈状态
(返址,n值,x值,y值,z值) 塔与圆盘的状态说明
3 1,2,3, 
9 
. 8,1,c,a,
b 
6,2,a,c,b 
0,3,a,b,c 
将1号圆盘由c移至b后, 
从语句(行)9退出第三层, 
返回至第二层的语句
(行)8。
从语句(行)9退出第二层, 
返回至第一层的语句
(行)6。
2 8,9 . 6,2,a,c,b 
0,3,a,b,c 
1 6,7 . 0,3,a,b,c 
将3号圆盘由a移至c后, 
从语句(行)7进入下一层
递归。
2 1,2,4, 
5 . 8,2,b,a,
c 
0,3,a,b,c 
从第二层的语句(行)5进
入第三层递归。
3 1,2,3, 
9 
. 6,1,b,c,
a 
8,2,b,a,c 
0,3,a,b,c 
将1号圆盘由b移至a后, 
从语句(行)9退出第三层
递归,返回至第二层语句
(行)6。
2 6,7 . 8,2,b,a,c 
0,3,a,b,c 
将2号圆盘由b移至c后, 
从语句(行)7进入下一层
递归。
3 1,2,3, 
9 
. 8,1,a,b,
c 
8,2,b,a,c 
0,3,a,b,c 
将1号圆盘由a移至c后, 
从语句(行)9退出第三层, 
返回至第二层语句(行)8。
从语句(行)9退出第二层, 
返回至第一层语句(行)8。2 8,9 8,2,b,a,c 
0,3,a,b,c 
1 8,9 
从语句(行)9退出递归函
数,返回至主函数。0,3,a,b,c 
0 栈空继续运行主函数。

图7(续)

3.
4 队列

3.
3.1 
抽象数据类型队列的定义
4.
和栈相反,队列(q是一种先进先出(缩写为FIFO)的线性表。
ueue) firstinfirstout, 
它只允许在表的一端进行插入,而在另一端删除元素。这和我们日常生活中的排队是一
・58・ 


致的,最早进入队列的元素最早离开。在队列中,允许插入的一端叫做队尾(rear), 允许
删除的一端则称为队头(front)。假设队列
为q=(a1,a2,…,an 
), 那么,a1 就是队头元
素,an 
则是队尾元素。队列中的元素是按照

a2,…,的顺序进入的,退出队列也只
能按照这个次序依次退出,也就是说,只有在
a2,…,才能退图3.

a1,an 

a1,n-1都离开队列之后,
n 
8 队列的示意图
出队列。图3.(a) 。(a) 

8是队列的示意图

队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在
允许多道程序运行的计算机系统中,同时有几个作业运行。如果运行的结果都需要通过
通道输出,那就要按请求输出的先后次序排队。每当通道传输完毕可以接受新的输出任
务时,队头的作业先从队列中退出作输出操作。凡是申请输出的作业都从队尾进入队列。

队列的操作与栈的操作类似,也有8个,不同的是删除是在表的头部(即队头)进行。
下面给出队列的抽象数据类型定义: 

ADTQueue{
数据对象:D={ai|ai∈ElSet,i=1,2,…,n,n≥0}
数据关系:R1={<ai-1,ai>(e) |ai(m) -1,ai∈D,i=2,…,n}
基本操作: 
约定其中a1端为队列头,an端为队列尾
。


InitQueue(&Q)
操作结果:构造一个空队列Q
。


DestroyQueue(&Q)
初始条件:队列Q已存在
。
操作结果:队列Q被销毁,不再存在
。


ClearQueue(&Q)
初始条件:队列Q已存在
。
操作结果:将Q清为空队列
。


QueueEmpty(Q)
初始条件:队列Q已存在
。
操作结果:若Q为空队列,则返回TRUE,否则FALSE
。


QueueLength(Q)
初始条件:队列Q已存在
。
操作结果:返回Q的元素个数,即队列的长度
。


GetHead(Q,&e)
初始条件:Q为非空队列
。
操作结果:用e返回Q的队头元素
。


EnQueue(&Q,e)
初始条件:队列Q已存在
。
操作结果:插入元素e为Q的新的队尾元素
。


DeQueue(&Q,&e)
初始条件:Q为非空队列
。
操作结果:删除Q的队头元素,并用e返回其值
。


・59・ 


QueTe(Q,iit()) 初(u) 始(r) 条(v) 件(r) :Q已(v) 存(s) 在且非空。(s) (e) 操作结果:从队头到队尾,依次对Q的每个数据元素调用函数visit()。一旦visit() 

失败,则操作失败
。
}ADTQueue


和栈类似,在本书以后各章中引用的队列都应是如上定义的队列类型。队列的数据

元素类型在应用程序内定义。
除了栈和队列之外,还有一种限定性数据结构是双端队列(deque)。
双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称做端点1 

和端点2(如图3.a) 可以用一个铁道转轨网络来比喻双端队列, 

9(b) 
9(所示)。也可像栈一样, 
如图3.所示。在实际使用中,还可以有输出受限的双端队列(即一个端点允许插入
和删除,另一个端点只允许插入的双端队列)和输入受限的双端队列(即一个端点允许插
入和删除,另一个端点只允许删除的双端队列)。而如果限定双端队列从某个端点插入的
元素只能从该端点删除,则该双端队列就蜕变为两个栈底相邻接的栈了。


图3.

9 双端队列示意图

(a)双端队列;(b)铁道转轨网
尽管双端队列看起来似乎比栈和队列更灵活,但实际上在应用程序中远不及栈和队
列有用,故在此不作详细讨论。

3.2 
链队列―――队列的链式表示和实现
4.
和线性表类似,队列也可以有两种存储表示。

用链表表示的队列简称为链队列,如图3.

10 所示。一个链队列显然需要两个分别指
示队头和队尾的指针(分别称为头指针和尾指针)才能惟一确定。这里,和线性表的单链
表一样,为了操作方便起见,我们也给链队列添加一个头结点,并令头指针指向头结点。
由此,空的链队列的判决条件为头指针和尾指针均指向头结点, 11(所示。

如图3.a)

链队列的操作即为单链表的插入和删除操作的特殊情况,只是尚需修改尾指针或头
指针,图3.b)d)展示了这两种操作进行时指针变化的情况。下面给出链队列类型
的模块说明
11
。
(~(

・60・ 


11 队列运算指针变化状况

图3.10 链队列示意图图3.

(a)空队列; (b)元素x入队列; 
(c)元素y入队列;(d)元素x出队列
∥====
= 
ADTQueue 
的表示与实现====
= 

∥-----单链队列―――队列的链式存储结构----
typedefstructQNode{
QElemType 
data; 

ctQNode 
*next;
}QNode(s) ,(t) *Q(u) (r) ueuePtr; 
typedefstruct{

QueuePtr 
frt;∥ 队头指针
QuePr 
rear(o) ;(n) ∥ 队尾指针
}LinkQueue;(t) (e) (u) 

∥-----基本操作的函数原型说明-----
StatusInitQueue(LinkQueue 
&Q)
∥ 构造一个空队列
Q 
StatusDesroyQueue(LinkQueue 
&Q)∥ 销毁(t) 队列Q,Q不再存在
StatusClearQueue(LinkQueue 
&Q)
∥ 将Q清为空队列
StatusQueueEmpy(LinkQueueQ)
∥ 若队列Q为(t) 空队列,则返回TRUE,否则返回FALSE 
intQueueLengh(LinkQueueQ)
∥ 返回Q的(t) 元素个数,即为队列的长度
StatusGetHead(LinkQueueQ,QElemType 
&e)
∥ 若队列不空,则用e返回Q的队头元素,并返回OK;否则返回ERROR 
StatusEnQueue(LinkQueue 
&Q,QElemTypee)
∥ 插入元素e为Q的新的队尾元素

StatusDeQueue(LinkQueue 
&Q,QElemType 
&e)

∥ 若队列不空,则删除Q的队头元素,用e返回其值,并返回OK; 

∥ 否则返回ERROR 

・61・ 


StatusQueueTraverse(LinkQueueQ,visit()) 
∥ 从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit失败,则操作失败。

∥-----基本操作的算法描述(部分)-----

StatusInitQueue(LinkQueue 
&Q)
{
∥ 构造一个空队列
Q
Qfnt=Qar= 
(QueuPr)malloc(sizeof(QNode))
;if(!Q(o) (r) (.) .rnxt(VRLW);(t) (e) ∥存储分配失
败


fot)e(e) (r) (.) iOEFO
Q.rn->nx=ULL;


fotetN
returnOK;
}


StatusDestroyQueue(LinkQueue 
&Q)
{
∥ 销毁队列
Q
whlQfot)
{


ie(.rn
Qar=Qft->next;
fre((e) (r) (.) .rn


eQfot);(n) (o) (r) (.) Q.rn.er;


fot=Qra

}
returnOK;
}


StatusEnQueue(LinkQueue 
&Q,QElemTypee){

∥ 插入元素e为Q的新的队尾元
素
p= 
(QeuePr)malloc(izeof(QNode))
;
if(!p)(u) xit(O(t) VERFLOW);(s) ∥存储分配失
败


p->data=(e) e; p->next= 
NULL;
Q.eret


ra->nx=p;
Q.er=p;


ra
returnOK;
}


StatusDeQueue(LinkQueue 
&Q,QElemType 
&e)
{
∥ 若队列不空,则删除Q的队头元素,用e返回其值,并返回OK;
∥ 否则返回ERROR


if(.rn=Qrr)eunERR;

Qfot 
=.artrRO
p= 
Q.rn->nx


fotet;(e) e=p->data;
Qfont->nt= 
p->next;


f((r) (.) r=ra.nt;

iQr=p)Q(x) (e) .er=Qfro
free(p(a) (e) (.) )
;
returnOK;
}


在上述模块的算法描述中,请读者注意删除队列头元素算法中的特殊情况。一般情
况下,删除队列头元素时仅需修改头结点中的指针,但当队列中最后一个元素被删后,队
・62・ 


343.
. 

列尾指针也丢失了,因此需对队尾指针重新赋值(指向头结点)。

循环队列―――队列的顺序表示和实现

和顺序栈相类似,在队列的顺序存储结构中,除了用一组地址连续的存储单元依次存
放从队列头到队列尾的元素之外,尚需附设两个指针front和rear分别指示队列头元素
及队列尾元素的位置。为了在C语言中描述方便起见,在此我们约定:初始化建空队列
时,令front=rear=0,每当插入新的队列尾元素时,“尾指针增1”;每当删除队列头元素
时,“头指针增1”。因此,在非空队列中,头指针始终指向队列头元素,而尾指针始终指向
队列尾元素的下一个位置,如图3.12 所示。


12 头、

图3.尾指针和队列中元素之间的关
系
(a)空队列;(b)J1、J2和J3相继入队列;(c)J1和J2相继被删除
;
(d)J4、J5和J6相继插入队列之后J3及J4被删
除


假设当前为队列分配的最大空间为6,则当队列处于图3.12(d)的状态时不可再继续
插入新的队尾元素,否则会因数组越界而遭致程序代码被破坏。然而此时又不宜如顺序
栈那样,进行存储再分配扩大数组空间,因为队列的实际可用空间并未占满。一个较巧妙
的办法是将顺序队列臆造为一个环状的空间,如图

3.13 所示,称之为循环队列。指针和队列元素之间
关系不变,如图3.14(a)所示循环队列中,队列头元
素是J3,队列尾元素是J5,之后J、J7 和J8 相继插入, 
14(b)所示,此时
Q.rn=rar;反之,若J、J4 和J5 相继从图则队列空间均被占满,如图3.(6) 
fotQ.e3 

3.14(a)的队列中删除,使队列呈“空”的状态,如
图3.c)所示。此时也存在关系式Q.图3.13 循环队列示意图
14(front= 
Q.refot=Q.e

ar,由此可见,只凭等式Q.rnrar无法判
别队列空间是“空”还是“满”。可有两种处理方法:其一是另设一个标志位以区别队列是
“空”还是“满”;其二是少用一个元素空间,约定以“队列头指针在队列尾指针的下一位置
(指环状的下一位置)上”作为队列呈“满”状态的标志。

从上述分析可见,在C语言中不能用动态分配的一维数组来实现循环队列。如果用
户的应用程序中设有循环队列,则必须为它设定一个最大队列长度;若用户无法预估所用
・63・ 



